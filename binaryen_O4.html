<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Binaryen goes to 4</title>

    <meta name="description" content="Big Web App? Compile It!">
    <meta name="author" content="Alon Zakai">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <style type="text/css">
      table {
        background-color: #fff !important;
        color: #000 !important;
        padding: 0.5em !important;
        border: 2px solid black !important;
        box-shadow: 0.2em 0.2em 0.2em rgba(0,0,0,0.9) !important;
        margin-top: 0.5em !important;
        margin-bottom: 0.5em !important;
      }
      td {
        vertical-align: middle !important;
        text-align: center !important;
      }
      strong {
        color: #fc5;
      }
    </style>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h2>Binaryen Optimizer Goes To 4</h2>
          <hr>
          <p><strong>Alon Zakai</strong> / <strong>June 2018</strong></p>
        </section>

        <section>
          <p>Most C or C++ compilers - gcc, clang, emcc - have flags like these:</p>
          <ul>
            <li><strong>-O1</strong>: "Optimize"</li>
            <li><strong>-O2</strong>: "Optimize even more"</li>
            <li><strong>-O3</strong>: "Optimize yet more"</li>
          </ul>
        </section>

        <section>
          <p>Because of the importance of code size on the Web, emcc compiles all the code at link time so it can best minimize it.</p>
          <p>That can take a while in huge projects, so the flags have also come to mean this:</p>
          <ul>
            <li><strong>-O1</strong>: Quick optimization, good for iteration</li>
            <li><strong>-O2</strong>: Reasonable optimization</li>
            <li><strong>-O3</strong>: Time-consuming optimization, good for release</li>
          </ul>
        </section>

        <section>
          <p>When emcc compiles to wasm, it invokes Binaryen to optimize that wasm.</p>
          <p>So Binaryen has also had <strong>-O1, -O2, -O3</strong>, to match.</p>
          <p>When you run <strong>emcc -O3 main.cpp</strong> this happens:</p>
          <center><table><tr>
            <td style="color: #c81">LLVM IR</td>
            <td>&rarr;</td>
            <td><b>LLVM -O3</b></td>
            <td>&rarr;</td>
            <td style="color: #c81">wasm</td>
            <td>&rarr;</td>
            <td><b>Binaryen -O3</b></td>
            <td>&rarr;</td>
            <td style="color: #c81">final wasm</td>
          </tr></table></center>
          <p>Binaryen has has been mostly tuned for that case, shrinking it by <strong>15%</strong>.</p>
        </section>

        <section>
          <p>But non-LLVM compilers are important too!</p>
          <p><strong>GC</strong> in wasm is going to be a huge deal: It will let us convert <strong>compile-to-js</strong> languages into <strong>compile-to-wasm</strong>.</p>
          <p>That is, we hope that programs in TypeScript, Elm, Reason, etc. will be able to benefit from wasm just by recompiling them:</p>
          <center><table><tr>
            <td style="color: #c81">the same<br>source code</td>
            <td>---&rarr;<br><br>---&rarr;</td>
            <td><b>JavaScript<br><br>WebAssembly</b></td>
          </tr></table></center>
          <p>Furthermore, GC makes new wasm-focused languages like AssemblyScript even more useful.</p>
also c++?
        </section>

        <section>
          <p>Binaryen makes it easier to write compilers for GC languages:</p>
          <ul>
            <li>Simpler IR to emit (can provide either basic blocks or structured control flow)</li>
            <li>Handles all the wasm binary format emitting details</li>
            <li>Usable from JS (binaryen.js) or C</li>
            <li>Optimizes & minifies</li>
          </ul>
        </section>

        <section>
          <p>We noticed on AssemblyScript that Binaryen didn't handle natural <strong>nested</strong> wasm code as well as LLVM-like <strong>flat</strong> code</p>
<table width=100%><tr>
<td>
          <pre>
;; LLVM would never emit this!
(func $nested (result i32)
 (i32.eqz
  (loop $loop (result i32)
   (br_if $loop
    (call $do-work)
   )
   (call $check-error)
  )
 )
)
</pre>
</td>
<td hidden=1>
<b>flatten</b><br>---&rarr;
</td>
<td hidden=1>
          <pre>
(func $nested (result i32)
 (local $0 i32)
 (local $1 i32)
 (local $2 i32)
 (loop $loop
  (set_local $0
   (call $do-work)
  )
  (br_if $loop
   (get_local $0)
  )
  (set_local $1
   (call $check-error)
  )
 )
 (set_local $2
  (i32.eqz
   (get_local $1)
  )
 )
 (return
  (get_local $2)
 )
)
</pre>
</td>
</tr></table>
        </section>

        <section>
          <p>Binaryen has a "<strong>flatten</strong>" pass:</p>
<table width=100%><tr>
<td>
          <pre>
;; LLVM would never emit this!
(func $nested (result i32)
 (i32.eqz
  (loop $loop (result i32)
   (br_if $loop
    (call $do-work)
   )
   (call $check-error)
  )
 )
)
</pre>
</td>
<td>
<b>flatten</b><br>---&rarr;
</td>
<td>
          <pre>
(func $nested (result i32)
 (local $0 i32)
 (local $1 i32)
 (local $2 i32)
 (loop $loop
  (set_local $0
   (call $do-work)
  )
  (br_if $loop
   (get_local $0)
  )
  (set_local $1
   (call $check-error)
  )
 )
 (set_local $2
  (i32.eqz
   (get_local $1)
  )
 )
 (return
  (get_local $2)
 )
)
</pre>
</td>
</tr></table>
        </section>

        <section>
          <p>The design idea: flat IR is just a subset</p>
          <ul>
            <li>Binaryen IR is almost identical to wasm, to allow efficient minification</li>
            <li>Most passes work on all Binaryen IR (but may be more efficient if flat)</li>
            <li>A few passes depend on flat IR (when hard to write a general pass)</li>
          </ul>
          <p>So just by flattening before running regular opts you get a boost.</p>
        </section>

        <section>
          <p>-O4 is flattening + the flat-only passes + -O3</p>
          <p>Not much large non-LLVM code yet to test on, but on fuzz testcases, -O4 does an extra 20% over -O3</p>
          <p>But also 3x slower - flat IR is much larger</p>
        </section>

        <section>
          <p>The End</p>
          <hr>
          <img src="Spinal_Tap_-_Up_to_Eleven.jpg"></img>
          <p>Binaryen now goes up to 4 - maybe someday we'll go <a href="https://en.wikipedia.org/wiki/Up_to_eleven">up to 11</a></p>
          <p>Thank you!</p>
          <hr>
          <small>(and watch Spinal Tap if you haven't already)</small>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: 'default', //Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

          // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
