<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Emscripten: Compiling LLVM bitcode to JavaScript</title>

    <meta name="description" content="JavaScript + Other Languages">
    <meta name="author" content="Alon Zakai">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/sky.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->

    <style type="text/css">
      h2 b {
        color: #048;
      }
      h3 b {
        color: #369;
      }
      b {
        color: #63a;
      }
      strong {
        color: #c11;
      }
    </style>

  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h2><b>Emscripten: Compiling<br> LLVM bitcode to <div style="color: #c11">JavaScript (?!)</div></b></h2>
          <br>
          <h3>Alon Zakai (Mozilla)</h3>
          <br>
          <p>Slides just tweeted at <a href="http://twitter.com/#!/kripken">@kripken</a></p>
        </section>

        <section>
          <h3><b>JavaScript..?</b></h3>
          <br>
          <img class="fragment" src="browser-logos.png" style="border: 0; box-shadow: none;">
          <br>
          <p class="fragment"><b>Everyone</b> has a browser</p>
          <p class="fragment">Browsers run <b>JavaScript</b></p>
        </section>

        <section>
          <h3><b>In other words</b></h3>
          <p class="fragment"><b>Everything</b> compiles into LLVM bitcode</p>
          <p class="fragment">JavaScript runs <b>everywhere</b></p>
          <p class="fragment"><strong>&dArr;</strong></p>
          <hr>
          <p class="fragment">Compiling LLVM bitcode to JavaScript would let us run everything, everywhere</p>
          <hr>
        </section>

        <section>
          <h3><b>And this works today!</b></h3>
          <p>some demos</p>
 Epic citadel, mess|other emulator, llvm ir in browser, clang?
        </section>

        <section>
          <h3><b>Ok, how does this work?</b></h3>
        </section>

        <section>
          <h3><b>LLVM vs. JavaScript</b></h3>
          <br>
          <p>Random (unrelated) code samples from each:</p>
          <pre><code>
    %r = load i32* %p
    %s = shl i32 %r 16
    %t = call i32 @calc(i32 %r, i32 %s)
    br label %next

</code></pre>
          <hr>
          <pre><code>
  var x = new MyClass('name', 5).chain(function() {
    doMore({ x: 5, y: [1,2,3] });
  });

</code></pre>
          <p>What could be more different? ;)</p>
        </section>

        <section>
          <h3><b>Types</b></h3>
          <p>LLVM: i8, i16, i32, float, double, etc.</p>
          <p>JS: double, object, array, function, etc.</p>
        </section>

        <section>
          <h3><b>Performance Model</b></h3>
          <p>LLVM: Types and operations almost map 1-1 to CPU</p>
          <p>JS: Virtual machine, just in time compilers, garbage collection, type profiling, etc.</p>
          <p>HOW DO I MAKE THIS FAST?!</p>
        </section>

        <section>
          <h3><b>Control Flow</b></h3>
          <p>LLVM: Functions, basic blocks and branches</p>
          <p>JS: Functions, ifs, loops - no goto!</p>
        </section>

        <section>
          <h3><b>Variables</b></h3>
          <p>LLVM: Local vars have function scope</p>
          <p>JS: Local vars have function scope</p>
          <p>OMG ITS THE SAME FOR ONCE</p>
        </section>

        <section>
          <h3><b>Emscripten's approach</b></h3>
          <p>Emit "low-level" JavaScript, very close to LLVM IR</p>
          <p>Avoid creating JS objects, arrays, closures, etc.</p>
          <p>Do create normal JS calls and local variables as much as possible</p>
        </section>

        <section>
          <h3><b>LLVM &rArr; JavaScript</b></h3>
          <br>
          <pre><code>
  define i32 @func(i32* %p) {
    %r = load i32* %p
    %s = shl i32 %r 16
    %t = call i32 @calc(i32 %r, i32 %s)
    ret i32 %t
  }

</code></pre>
          <hr>
          <pre><code>
  function func(p) {
    var r = HEAP[p];
    return calc(r, r << 16);
  }

</code></pre>
        </section>

        <section>
          <pre><code contenteditable>  float array[5000]; // C++
  int main() {
    for (int i = 0; i < 5000; ++i) {
      array[i] += 1.0f;
    }
  }</code></pre>
          <h3><b>&rArr; emscripten &rArr;</b></h3>
          <pre><code contenteditable>  var g = Float32Array(32768); // JavaScript
  function main() {
    var a = 0, b = 0;
    do {
      a = 8 + (b << 2) | 0;
      g[a >> 2] = +g[a >> 2] + 1.0;
      b = b + 1 | 0;
    } while ((b | 0) < 5000);
  }</code></pre>
          <p class="fragment">This is a subset of JS called <b><a href="http://asmjs.org">asm.js</a></b></p>
        </section>

        <section>
          <h3><b>asm.js</b></h3>
          <p>An <b>optimizable subset of JavaScript</b>, intended primary as a compiler target</p>
          <p class="fragment"><b>Avoids potential slowdowns</b> (types changing, GC pauses)</p>
          <p class="fragment"><strong>Low-level</strong> and <strong>easy to optimize</strong></p>
        </section>

        <section>
          <h3><b>Why so low-level?</b></h3>
          <p>Emscripten and other compilers to JS have experimented with "higher-level" output</p>
          <p>For example, perhaps each LLVM structure could be a JS object?</p>
          <p>But how would we take pointers to interior fields?</p>
          <p>Must allow all LLVM optimizations, and those assume a memory model where e.g. it is ok to read an i32 and splitting it up, as opposed to reading two i16s</p>
    * Optimizations that make our lives difficult, e.g. load i64, bitcast to double, then work on that - bad for us
        </section>

        <section>
          <h3><b>Emscripten Architecture</b></h3>
          <p>LLVM assembly => Emscripten Compiler => Emscripten Optimizer</p>
          <p>Compiler and optimizer are written in JavaScript</p>
          <p>NOT an LLVM backend (discussion of mandreel and duetto approaches)</p>
        </section>

        <section>
          <h3><b>Why no backend?</b></h3>
          <p>JS is such an odd target, maximal flexibility in codegen seemed crucial</p>
          <p>Helped prototype and test various models over the years</p>
          <p>But final model is in fact fairly low-level and close to what an LLVM backend would emit</p>
        </section>

        <section>
          <h3><b>Why no backend?</b></h3>
          <p>Even so, not sure about feasibility of doing some things in an LLVM backend:</p>
          <p>(I am sure anything is possible with enough work, question is practicality)</p>
          <p>Expressionizer, with precise JS semantics</p>
          <p>Variable consolidation, but not real regalloc, different goals (JS engine will regalloc anyhow)</p>
          <p>Misc stuff like function calls using normal JS and not the C stack</p>
        </section>

        <section>
          <h3><b>Why no backend?</b></h3>
          <p>At least 3 compilers from LLVM to JS, each with a different approach:</p>
          <p>Mandreel: LLVM backend using tblgen, selection DAG (like SPARC backend)</p>
          <p>Duetto: Backend doing passes on LLVM Module object (like C++ backend)</p>
          <p>Emscripten: External backend that reads LLVM bitcode and has its own IR</p>
        </section>

        <section>
          <h3><b>Emscripten: Compiler</b></h3>
          <p>Parse LLVM assembly into Emscripten internal IR</p>
          <p>Legalize</p>
          <p>Emit blocks by generating JS for each LLVM instruction separately</p>
          <p>Reloop - generate loops and ifs from basic blocks</p>
          <p>Special-case code to handle some tricky things, like longjmp using JS exceptions</p>
        </section>

        <section>
          <h3><b>Emscripten: Optimizer</b></h3>
          <p>Parse JS (using UglifyJS)</p>
          <p>Expressionize - model JS semantics exactly (sometimes surprising), easier on JS AST</p>
          <p>Registerize</p>
          <p>Miscellaneous peephole optimizations</p>
        </section>

        <section>
          <h3><b>Emscripten - Status</b></h3>
          <p>Quite stable, used in production on very large codebases (Unreal Engine, etc.)</p>
          <p>Improving in tandem with JS language - new features in JS can be used by Emscripten (e.g. SIMD - LLVM autovectorization works), and the needs of compilers to JS have been listened to in the JS standards bodies - E.g. Math.imul, Math.fround</p>
        </section>

        <section>
          <h3><b>Issues</b></h3>
          <p>Thoughts, comments on the following would be very welcome!</p>
<p>
  * Compilation speed - takes a few minutes for a full rebuild of a million lines of code
  * Upstream parts? Relooper is in C++ and already used by other projects (e.g. Duetto)?
  * SHould we write more to C++? Perhaps an LLVM backend (which kind)?
  * list of things we can do for wins:
    * optimize llvm-link
    * optimize our useage of opt, opt and dis to a single binary, no serializing
      * clang => opt => llvm-dis => compiler => optimizer
    * minifier LLVM IR pass
</p>
        </section>










        <section>
          <h3><b>Performance</b></h3>
          <a href="asm_jul_10_2013.png"><img src="asm_jul_10_2013.png" style="box-shadow: 5px 5px 5px rgba(0,0,0,0.2)"></a>
          <p><small>(VMs and Emscripten from July 10th 2013, run on 64-bit linux)</small></p>
        </section>

        <section>
          <h3><b>Uses</b></h3>
          <p>Not just for games, but for <strong>anything</strong> that needs raw computation</p>
          <ul>
            <li class="fragment"><b>Physics</b> engines like <a href="ammo/ammo.html">Bullet</a></li>
            <li class="fragment"><b>3D plotting</b> using <a href="http://gnuplot.respawned.com/">GNU plot</a></li>
            <li class="fragment"><b>2D graphing</b> using <a href="http://mdaines.github.io/viz.js/example.html">graphviz</a></li>
            <li class="fragment"><b>PNG compression</b> using <a href="http://richardassar.github.io/pngcrush.js/">pngcrush</a></li>
            <li class="fragment">Even <b>programming languages</b> like <a href="http://kripken.github.io/lua.vm.js/repl.html">Lua</a></li>
          </ul>
        </section>

        <section>
          <h3><b>Summary</b></h3>
          <p class="fragment">In modern browsers we can run code at <b>near-native</b> speed</p>
          <p class="fragment">Write in C/C++, compile to <b>asm.js</b></p>
          <p class="fragment">Why spend money on servers? <b>;)</b></p>
          <div class="fragment">
            <hr>
            <p><b style="color: #c11">That's it! Questions?</b></p>
          </div>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: 'sky', //Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

          // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
