<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Emscripten: Compiling LLVM bitcode to JavaScript</title>

    <meta name="description" content="JavaScript + Other Languages">
    <meta name="author" content="Alon Zakai">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/sky.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->

    <style type="text/css">
      h2 b {
        color: #048;
      }
      h3 b {
        color: #369;
      }
      b {
        color: #63a;
      }
      strong {
        color: #c11;
      }
    </style>

  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h2><b>Emscripten: Compiling<br> LLVM bitcode to <div style="color: #c11">JavaScript (?!)</div></b></h2>
          <br>
          <h3>Alon Zakai (Mozilla)</h3>
          <br>
          <p>(slides just tweeted at <a href="http://twitter.com/#!/kripken">@kripken</a>)</p>
        </section>

        <section>
          <h3><b>JavaScript..?</b></h3>
          <br>
          <div class="fragment">
            <img src="browser-logos.png" style="border: 0; box-shadow: none;">
            <br>
            <p><b>Everyone</b> has a browser</p>
          </div>
          <p class="fragment">Browsers run <b>JavaScript</b></p>
        </section>

        <section>
          <h3><b>In other words</b></h3>
          <br>
          <p class="fragment"><b>Everything</b> compiles into LLVM bitcode</p>
          <p class="fragment">JavaScript runs <b>everywhere</b></p>
          <p class="fragment">..so..</p>
          <div class="fragment">
            <br>
            <p>Compiling LLVM bitcode to JavaScript would let us run <strong>everything, everywhere</strong></p>
          </div>
        </section>

        <section>
          <h3><b>And this works today!</b></h3>
          <br>
          <ul>
            <li><b>Game engines</b> like <a href="epic/EpicCitadel.html">Unreal Engine 3</a></li>
            <li><b>Emulators</b> like <a href="mess/messloader.html?module=c64">MESS</a></li>
            <li><b>Physics engines</b> like <a href="ammo/ammo.html">Bullet</a></li>
            <li><b>Programming languages</b> like <a href="http://kripken.github.io/lua.vm.js/repl.html">Lua</a></li>
          </ul>
        </section>

        <section>
          <h3>Ok, <b>how</b> does this work?</b></h3>
        </section>

        <section>
          <h3><b>LLVM vs. JavaScript</b></h3>
          <br>
          <p>Random (unrelated) code samples from each:</p>
          <pre><code>
    %r = load i32* %p
    %s = shl i32 %r 16
    %t = call i32 @calc(i32 %r, i32 %s)
    br label %next

</code></pre>
          <hr>
          <pre><code>
  var x = new MyClass('name', 5).chain(function() {
    doMore({ x: 5, y: [1,2,3] });
  });

</code></pre>
          <p class="fragment">What could be more different? ;)</p>
        </section>

        <section>
          <h3><b>Types</b></h3>
          <br>
          <center>
          <table>
            <tr><td><b>LLVM</b></td><td width="5%"></td><td><center>i8, i16, i32, float, double, etc.</center></td></tr>
            <tr><td><hr></td><td width="5%"></td><td><hr></td></tr>
            <tr><td><b><center>JS</center></b></td><td width="5%"></td><td>double, object, array, function, etc.</td></tr>
          </table>
          </center>
        </section>

        <section>
          <h3><b>Performance Model</b></h3>
          <br>
          <center>
          <table>
            <tr><td><b>LLVM</b></td><td width="5%"></td><td><center>Types and operations almost map 1-1 to CPU</center></td></tr>
            <tr><td><hr></td><td width="5%"></td><td><hr></td></tr>
            <tr><td><b><center>JS</center></b></td><td width="5%"></td><td><center>Virtual machine (VM), just in time (JIT) compilers w/type profiling, garbage collection, etc. (HOW DO I MAKE THIS FAST?!)</center></td></tr>
          </table>
          </center>
        </section>

        <section>
          <h3><b>Control Flow</b></h3>
          <br>
          <center>
          <table>
            <tr><td><b>LLVM</b></td><td width="5%"></td><td><center>Functions, basic blocks and branches</center></td></tr>
            <tr><td><hr></td><td width="5%"></td><td><hr></td></tr>
            <tr><td><b><center>JS</center></b></td><td width="5%"></td><td><center>Functions, ifs and loops - no goto!</center></td></tr>
          </table>
          </center>
        </section>

        <section>
          <h3><b>Variables</b></h3>
          <br>
          <center>
          <table>
            <tr><td><b>LLVM</b></td><td width="5%"></td><td><center>Local vars have function scope</center></td></tr>
            <tr><td><hr></td><td width="5%"></td><td><hr></td></tr>
            <tr><td><b><center>JS</center></b></td><td width="5%"></td><td><center>Local vars have function scope</center></td></tr>
          </table>
          </center>
          <br>
          <p class="fragment"><img src="thesame.jpg" style="border: 1px solid black; box-shadow: 5px 5px 5px rgba(0,0,0,0.2)" width="33%"></p>
        </section>

        <section>
          <h3><b>Ok, how do we get<br>around these issues?</b></h3>
          <br>
          <p>(except for local vars, those are just fine. 1% of the problem is already solved!)</p>
        </section>

        <section>
          <h3><b>Emscripten's approach</b></h3>
          <br>
          <p>Emit "low-level" JavaScript, close to LLVM IR</p>
          <p class="fragment">No JS objects, arrays, closures, etc.</p>
          <p class="fragment">But <b>do</b> emit normal JS calls, vars, etc.</p>
        </section>

        <section>
          <pre><code>
  define i32 @func(i32* %p) {
    %r = load i32* %p
    %s = shl i32 %r 16
    %t = call i32 @calc(i32 %r, i32 %s)
    ret i32 %t
  }

</code></pre>
          <p><b>&rArr;</b> emscripten <b>&rArr;</b></p>
          <pre><code>
  function func(p) {
    var r = HEAP[p];
    return calc(r, r << 16);
  }

</code></pre>
        </section>

        <section>
          <p>Another example:</p>
          <pre><code contenteditable>  float array[5000]; // C++
  int main() {
    for (int i = 0; i < 5000; ++i) {
      array[i] += 1.0f;
    }
  }</code></pre>
          <p><b>&rArr;</b> emscripten <b>&rArr;</b></p>
          <pre><code contenteditable>  var g = Float32Array(32768); // JavaScript
  function main() {
    var a = 0, b = 0;
    do {
      a = 8 + (b << 2) | 0;
      g[a >> 2] = +g[a >> 2] + 1.0;
      b = b + 1 | 0;
    } while ((b | 0) < 5000);
  }</code></pre>
          <p class="fragment">This "style" of code is a subset of JS called <b><a href="http://asmjs.org">asm.js</a></b></p>
        </section>

        <section>
          <h3><b>asm.js: low-level JS</b></h3>
          <br>
          <p>asm.js is a subset of JS that is low-level and easy to optimize</p>
          <p class="fragment">Defined by a type system so easy to check if you fall in that subset</p>
          <p class="fragment">JS engines can optimize things like <code>|0</code> etc. into code about as efficient as native code</p>
        </section>

        <section>
          <h3><b>Performance</b></h3>
          <a href="asm_jul_10_2013.png"><img src="asm_jul_10_2013.png" style="box-shadow: 5px 5px 5px rgba(0,0,0,0.2)"></a>
          <p><small>(VMs and Emscripten from July 10th 2013, run on 64-bit linux)</small></p>
        </section>

        <section>
          <h3><b>Why so low-level?</b></h3>
          <br>
          <p>Emscripten and other compilers to JS have experimented with "higher-level" output (e.g., each C++ object is a JS object)</p>
          <p>Low-level is almost always faster</p>
        </section>

        <section>
          <h3><b>Low-level upsides</b></h3>
          <br>
          <p>Pointers are just numbers, not references to objects</p>
          <p class="fragment">Reads/writes on typed arrays can become literal reads/writes from memory</p>
          <p class="fragment">Low-level means memory model is identical to LLVM's, so can use all LLVM opts</p>
        </section>

        <section>
          <h3><b>Low-level downsides</b></h3>
          <br>
          <p>LLVM optimizer can load 2 floats as an i64, then bitcast the 32-bit chunks to floats (e.g. Box2D)</p>
          <p class="fragment">This is bad for JS since there is no fast way to bitcast ints to floats!</p>
          <div class="fragment">
            <p>Emscripten has a pass to optimize away such things (are we doing it wrong?)</p>
            <p><img src="doingitwrong.jpg" style="border: 1px solid black; box-shadow: 5px 5px 5px rgba(0,0,0,0.2)" width="33%"></p>
          </div>
        </section>

        <section>
          <h3><b>Emscripten Architecture</b></h3>
          <br>
          <p>LLVM assembly => Emscripten Compiler => Emscripten Optimizer</p>
          <p class="fragment">Compiler and optimizer are written in JavaScript</p>
          <p class="fragment">Wait, that's not an LLVM backend..?</p>
        </section>

        <section>
          <h3><b>3 compilers, 3 ways</b></h3>
          <br>
          <p>
          <ul>
            <li>Mandreel: Typical LLVM backend, uses tblgen, selection DAG (like x86, ARM backends)</li>
            <li>Duetto: Processes LLVM IR in llvm::Module (like C++ backend)</li>
            <li>Emscripten: Processes LLVM IR in assembly</li>
          </ul>
          </p>
          <br>
          <p class="fragment">What is the best approach?</p>
        </section>

        <section>
          <h3><b>Why no backend?</b></h3>
          <br>
          <p>JS is such an odd target, maximal flexibility in codegen seemed crucial in Emscripten</p>
          <p>Helped prototype and test various models over the years</p>
          <p>But final model is in fact fairly low-level and close to what an LLVM backend would emit</p>
          <p>And Emscripten currently must do legalization on its own</p>
        </section>

        <section>
          <h3><b>LLVM backend?</b></h3>
          <br>
          <p>So perhaps an LLVM backend makes sense, and Emscripten can consider it</p>
          <p>But JS differs from "typical" machine targets in many ways, in particular it has 3 crucial optimizations that we need to see how practical it is to do in an LLVM backend</p>
        </section>

        <section>
          <h3><b>1. Expressionize</b></h3>
          <pre><code>
  var a = g(x);
  var b = a + y;
  var c = HEAP[b];
  var d = HEAP[20];
  var e = x + y + z;
  var f = h(d, e);
  FUNCTION_TABLE[c](f);

</code></pre>
          <h3><b>&rArr;</b></h3>
          <pre><code>
  FUNCTION_TABLE[HEAP[g(x) + y](h(HEAP[20], x + y + z));

</code></pre>
          <p class="fragment">Must model JS semantics (order of operations, etc.) precisely (sometimes surprising!)</p>
        </section>

        <section>
          <h3><b>2. Registerize</b></h3>
          <pre><code>
  var a = g(x) | 0; // integers 
  var b = a + y | 0;
  var c = HEAP[b] | 0;
  var d = +HEAP[20]; // float

</code></pre>
          <h3><b>&rArr;</b></h3>
          <pre><code>
  var a = g(x) | 0;
  a = a + y | 0;
  a = HEAP[a] | 0;
  var b = +HEAP[20];

</code></pre>
          <p class="fragment">Looks like regalloc, but goal is different: Minimize # of total variables (in each type), not spills (JS VMs will do their own regalloc!)</p>
        </section>

        <section>
          <h3><b>3. Reloop</b></h3>
          <pre><code>
  block1:
    ; code1
    br i1 %cond, %label block1, label %block2

  block2:
    ; code2
    br %label block1

</code></pre>
          <h3><b>&rArr;</b></h3>
          <pre><code>
  while (1) {
    do {
      // code1
    } while (cond);
    // code2
  }

</code></pre>
        </section>

        <section>
          <h3><b>Optimizations: Summary</b></h3>
          <br>
          <p>Reloop is more generic, and the Emscripten code is already used by other LLVM-based projects like Duetto</p>
          <p class="fragment">Expressionize and Registerize require a precise modelling of JS semantics. Concern is we would need to basically add a JS AST into LLVM. Or is there a good way in an LLVM backend?</p>
        </section>

        <section>
          <h3><b>JS as a compilation target</b></h3>
          <br>
          <p>Began as a slow interpreted language, became a JITed language</p>
          <p>Emscripten and Mandreel output led to JS VM optimizations and asm.js</p>
          <p>Collaboration with JS standards bodies led to some new JS language features (Math.imul)</p>
        </section>

        <section>
          <h3><b>float32</b></h3>
          <p>JS numbers are doubles, and hard to emulate 32-bit float's lower precision (and higher speed)</p>
          <p>Math.fround is a new JS feature that rounds 64-bit doubles to 32-bit floats</p>
          <pre><code>
  var a = Math.fround(1.23456789);
  var b = Math.fround(9.9E99);
  print(Math.fround(a + b));

</code></pre>
          <p>JS engines can optimize that into 32-bit floats, no doubles. So Emscripten can emit JS that translates LLVM floats into floats in JS VMs</p>
        </section>

        <section>
          <h3><b>SIMD</b></h3>
          <br>
          <p>Single Instruction, Multiple Data: <b>SSE</b>, <b>NEON</b>, etc.</p>
          <p class="fragment"><a href="https://github.com/johnmccutchan/ecmascript_simd">SIMD</a> is coming to JS</p>
          <p class="fragment">Emscripten supports LLVM vector types, so both C SIMD intrinsics and LLVM autovectorization work</p>
          <p class="fragment">When SIMD spec is finalized and JS engines support, it will be fast</p>
        </section>

        <section>
          <h3><b>Summary</b></h3>
          <br>
          <p class="fragment">LLVM bitcode can be compiled to JavaScript</p>
          <p class="fragment">Allows LLVM bitcode to run in all browers, at high speeds</p>
          <p class="fragment">Approach is seeing adoption on the web, by games companies, etc.</p>
          <div class="fragment">
            <hr>
            <p><b style="color: #c11">That's it! Questions?</b></p>
          </div>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: 'sky', //Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

          // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
