





<section>
  <h3><b>C++ and the Web</b></h3>
  <br>
  <p>All major web browsers are written in C++ [image]</p>
  <p>For the obvious reasons: Fast, familiar, plenty of libraries</p>
  <p>But that's <b>not</b> what I'm going to talk about here!</p>
</section>

<section>
  <h3><b>The Modern Web</b></h3>
  <br>
  <p>Modern, standards-compliant web content is built using HTML, CSS, JavaScript and GLSL</p>
  <p>There are also plugins that are not standard and work only in some browsers and operating systems (Flash, Java, Silverlight, Unity, NaCl, etc.)</p>
  <p>Plugins, for the most part, are on the way out</p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p>Writing code for the modern web, we therefore have... JavaScript</p>
  <p>JavaScript is a dynamic language</p>
  <pre><code>
  var x = waka() // no types
  </code></pre>
  <p>It runs in a VM, is just-in-time (JIT) compiled, etc.</p>
  <p>Portable</p>
  <p>Sandboxed</p>
</section>

<section>
  <h3><b>JavaScript</b></h3>
  <br>
  <p>Some people hate it</p>
  <p>Some people love it so much they use it on their servers too (node.js)</p>
  <p>Other people happen to prefer another language, and <b>compile</b> it to JavaScript</p>
</section>

<section>
  <h3><b>C and C++ on the Web</b></h3>
  <br>
  <p>We can't run C &amp; C++ on the web, but we can compile it into JavaScript which does</p>
  <p>Instead of compiling to x86 or ARM assembly, we compile to JavaScript as the "assembly of the web"</p>
</section>

<section>
  <h3><b>Usage</b></h3>
  <br>
  <pre><code>  // hello.cpp
  #include <stdio.h>
  int main() {
    printf("hello, world!\n");
  }
  </code></pre>
  <hr>
  <pre><code>  $ gcc hello.cpp -o hello
  $ ./hello
  hello, world!
  </code></pre>
  <hr>
  <pre><code> $ emcc hello.coo -o hello.html
  $ firefox hello.html
  </code></pre>
  <hr>
  <p>[live iframe!]</p>
</section>

<section>
  <h3><b>C and C++ as JavaScript</b></h3>
  <br>
  <p>As JavaScript, our code will be portable and sandboxed - we can't get around that (nor do we want to!)</p>
  <p>No direct access to local system libs, local filesystem, etc. - can only do things a website can</p>
  <p>Different performance between different browsers/JS VMs</p>
  <p>Overall a very different environment than C and C++ are usually run on!</p>
</section>

<section>
  <h3><b>Example Ports</b></h3>
  <br>
  <p>Unity, Epic, etc. - multimillion-line C++ codebases work fine</p>
</section>

<section>
  <h3><b>How does this work?</b></h3>
  <br>
  <p><b>Emscripten</b>, the compiler used in those examples, is LLVM-based</p>
  <p>clang frontend, LLVM optimizations, then convert LLVM bitcode into JavaScript</p>
  <p>robustness is comparable to native backends: we can run the csmith fuzzer without finding new Emscripten-specific issues</p>
</section>

<section>
  <h3><b>Numeric Types</b></h3>
  <br>
  <center>
  <table>
    <tr><td><b>LLVM</b></td><td width="5%"></td><td><center>i8, i16, i32, float, double</center></td></tr>
    <tr><td><hr></td><td width="5%"></td><td><hr></td></tr>
    <tr><td><b><center>JS</center></b></td><td width="5%"></td><td><center>double</center></td></tr>
  </table>
  </center>
</section>

<section>
  <h3><b>Performance Model</b></h3>
  <br>
  <center>
  <table>
    <tr><td><b>LLVM</b></td><td width="5%"></td><td><center>types and ops map ~1:1 to CPU</center></td></tr>
    <tr><td><hr></td><td width="5%"></td><td><hr></td></tr>
    <tr><td><b><center>JS</center></b></td><td width="5%"></td><td><center>virtual machine (VM), just in time (JIT) compilers w/ type profiling, garbage collection, etc.</center></td></tr>
  </table>
  </center>
</section>

<section>
  <h3><b>Control Flow</b></h3>
  <br>
  <center>
  <table>
    <tr><td><b>LLVM</b></td><td width="5%"></td><td><center>Functions, basic blocks &amp; branches</center></td></tr>
    <tr><td><hr></td><td width="5%"></td><td><hr></td></tr>
    <tr><td><b><center>JS</center></b></td><td width="5%"></td><td><center>Functions, ifs and loops - no goto!</center></td></tr>
  </table>
  </center>
</section>

<section>
  <h3><b>Variables</b></h3>
  <br>
  <center>
  <table>
    <tr><td><b>LLVM</b></td><td width="5%"></td><td><center>Local vars have function scope</center></td></tr>
    <tr><td><hr></td><td width="5%"></td><td><hr></td></tr>
    <tr><td><b><center>JS</center></b></td><td width="5%"></td><td><center class="fragment">Local vars have function scope</center></td></tr>
  </table>
  </center>
  <br>
  <div>
    <p class="fragment" style="margin: 0 auto; text-align:center; padding: 2em">Ironic, actually - many wish JS had <strong>block</strong> scope, like most languages...</p>
  </div>
</section>

<section>
  <h3><b>Ok, how do we get<br>around these issues?</b></h3>
</section>

<section>
  <pre><code>
// LLVM IR
define i32 @func(i32* %p) {
%r = load i32* %p
%s = shl i32 %r, 16
%t = call i32 @calc(i32 %r, i32 %s)
ret i32 %t
}

</code></pre>
  <p><b>&rArr;</b> Emscripten <b>&rArr;</b></p>
  <pre><code>
// JS
function func(p) {
var r = HEAP[p];
return calc(r, r << 16);
}

</code></pre>
  <p class="fragment">Almost direct mapping in many cases</p>
</section>

<section>
  <p>Another example:</p>
  <pre><code contenteditable>  float array[5000]; // C++
int main() {
for (int i = 0; i < 5000; ++i) {
array[i] += 1.0f;
}
}</code></pre>
  <p><b>&rArr;</b> Emscripten <b>&rArr;</b></p>
  <pre><code contenteditable>  var heap = new ArrayBuffer(32768); // JS
var g = new Float32Array(heap);
function main() {
var a = 0, b = 0;
do {
a = 8 + (b << 2) | 0;
g[a >> 2] = +g[a >> 2] + 1.0;
b = b + 1 | 0;
} while ((b | 0) < 5000);
}</code></pre>
  <p class="fragment">This "style" of code is a subset of JS called <b><a href="http://asmjs.org">asm.js</a></b></p>
</section>

<section>
  <p>JS began as a slow interpreted language</p>
  <br>
  <p class="fragment">Competition &rArr; <b>type-specializing</b> JITs</p>
  <br>
  <p class="fragment">Those are very good at <b>statically typed</b> code</p>
</section>

<section>
  <p>But many <b>heuristics</b> lie between source code and actually being fully typed and optimized</p>
  <br>
  <p class='fragment'>What if we made some JS code <b>really really easy</b> to optimize, with as few heuristics as possible?</p>
  <br>
  <p class='fragment'>That's basically what <strong>asm.js</strong> is</p>
</section>

<section>
  <p>asm.js is a <b>subset</b> of JavaScript (not a new language, no new semantics, all 100% backwards compatible), written in a format that is extremely <b>easy to optimize</b></p>
  <br>
  <div class="fragment">
  <pre><code>
function twice(x) {
x = x | 0;
return x + x | 0;
}
  </code></pre>
  <br>
  <p><code>(x+1)|0</code> &nbsp; <b>&rArr;</b> &nbsp; 32-bit integer + in modern JS VMs</p>
  <br>
  <p>No need to profile types, can be optimized ahead of time (AOT) from source</p>
  </div>
</section>

<section>
  <pre><code>  var heap = new ArrayBuffer(32768);
var heap8 = new Int8Array(heap);
var heap16 = new Int16Array(heap);
var heap32 = new Int32Array(heap);

function mem_access() {
return heap32[heap8[100] >> 2];
}</code></pre>
  <br>
  <p><strong>Loads</strong> in LLVM IR become <strong>reads</strong> from typed arrays in JS, which become <strong>reads</strong> in machine code</p>
  <br>
  <p class="fragment">Emscripten's <b>memory model</b> is identical to LLVM's, including aliasing, so can use <b>all</b> LLVM opts</p>
</section>

<section>
  <h3><b>Optimizing</b></h3>
  <br>
  <p>Aside from LLVM running normal compiler optimizations (licm, alias analysis, etc.), Emscripten has <strong>3 JS-specific optimizations</strong> as well</p>
</section>

<section>
  <h3><b>1. Reloop</b></h3>
  <pre><code>  block0:
; code0
br i1 %cond, label %block0, label %block1

block1:
; code1
br %label block0
</code></pre>
  <p>Without relooping (emulated gotos):</p>
  <pre><code>  var label = 0;
while (1) switch (label) {
case 0:
// code0
label = cond ? 0 : 1; break;
case 1:
// code1
label = 0; break;
}
</code></pre>
</section>

<section>
  <h3><b>1. Reloop</b></h3>
  <pre><code>  block0:
; code0
br i1 %cond, label %block0, label %block1

block1:
; code1
br %label block0
</code></pre>
  <p>With relooping:</p>
  <pre><code>
while (1) {
do {
// code0
} while (cond);
// code1
}


</code></pre>
</section>

<section>
  <h3><b>1. Reloop</b></h3>
  <br>
  <p>Relooping allows JS VM to optimize better, as it can <strong>understand</strong> control flow</p>
  <br>
  <p class="fragment">Emscripten Relooper code is <b>generic</b>, written in C++, and used by other projects (e.g., Duetto)</p>
</section>

<section>
  <h3><b>2. Expressionize</b></h3>
  <pre><code>
var a = g(x);
var b = a + y;
var c = HEAP[b];
var d = HEAP[20];
var e = x + y + z;
var f = h(d, e);
FUNCTION_TABLE[c](f);

</code></pre>
  <h3><b>&rArr;</b></h3>
  <pre><code>
FUNCTION_TABLE[HEAP[g(x) + y](h(HEAP[20], x + y + z));

</code></pre>
</section>

<section>
  <h3><b>2. Expressionize</b></h3>
  <br>
  <p>Improves <b>JIT time</b> and <b>execution speed</b>: fewer variables &rArr; less stuff for JS engines to worry about</p>
  <br>
  <p class="fragment">Reduces <b>code size</b></p>
</section>

<section>
  <h3><b>3. Registerize</b></h3>
  <pre><code>
var a = g(x) | 0; // integers 
var b = a + y | 0;
var c = HEAP[b] | 0;
var d = +HEAP[20]; // double

</code></pre>
  <h3><b>&rArr;</b></h3>
  <pre><code>
var a = g(x) | 0;
a = a + y | 0;
a = HEAP[a] | 0;
var d = +HEAP[20];

</code></pre>
</section>

<section>
  <h3><b>3. Registerize</b></h3>
  <br>
  <p>Looks like regalloc, but goal is different: Minimize <strong># of total variables</strong> (in each type), <b>not</b> spills</p>
  <br>
  <p class="fragment">JS VMs will do regalloc, only they know the actual # of registers</p>
  <br>
  <p class="fragment">Benefits <b>code size &amp; speed</b> like expressionize</p>
</section>


advanced topics
  memory spaces (moving around typed arrays, no shared memory)
  memory fragmentation



<section>
  <h3><b>Remaining issues</b></h3>
  <br>
  <p>Practically any portable C or C++ applications can be ported to the web using this approach, generally with few or no changes</p>
  <p>However, some content will run more slowly: 64-bit integers, setjmp, C++ exceptions</p>
  <p>Those are current limitations in JavaScript and/or Emscripten, hopefully will vanish</p>
  <p>But there are some bigger problems</p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

<section>
  <h3><b></b></h3>
  <br>
  <p></p>
</section>

