<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Emscripten's WebAssembly Toolchain Story</title>

    <meta name="description" content="Big Web App? Compile It!">
    <meta name="author" content="Alon Zakai">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <style type="text/css">
      table {
        background-color: #fff !important;
        color: #000 !important;
        padding: 0.5em !important;
        border: 2px solid black !important;
        box-shadow: 0.2em 0.2em 0.2em rgba(0,0,0,0.9) !important;
        margin-top: 0.5em !important;
        margin-bottom: 0.5em !important;
      }
      td {
        vertical-align: middle !important;
        text-align: center !important;
      }
      strong {
        color: #fc5;
      }
    </style>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h1><br>WebAssembly<br>Toolchain Stories</h1>
          <br>
          <h3><div style="color: #f85">Alon Zakai</div></h3>
          <h3><div style="color: #fc5">December 2016</div></h3>
        </section>

        <section>
          <p>To understand our current WebAssembly toolchains, let's see how we got here</p>
        </section>

        <section>
          <h2>2010</h2>
          <p>"Can C++ be compiled to JavaScript so it runs on the web?"</p>
          <p><img src="i-have-no-idea-what-im-doing-dog.jpg" style="border: 1px solid black; box-shadow: 0.2em 0.2em 0.2em rgba(0,0,0,0.9);"></img></p>
          <p>&rarr; the <a href="http://emscripten.org/">Emscripten</a> project</p>
        </section>

        <section>
          <p>Earliest prototypes were <a href="http://mozakai.blogspot.com/2010/07/experiments-with-static-javascript-as.html">very hackish</a></p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR text</td>
            <td>&rarr;</td>
            <td>Python hacks</td>
            <td>&rarr;</td>
            <td style="color: #c81">JS</td>
          </tr></table></center>
        </section>

        <section>
          <p>A more serious approach: <strong>Emscripten's JS compiler</strong></p>
          <p>Generates JS, written in JS (great for experimentation)</p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR text</td>
            <td>&rarr;</td>
            <td><b>JS compiler</b></td>
            <td>&rarr;</td>
            <td style="color: #c81">JS</td>
          </tr></table></center>
          <p>(what's new is in <b style="background-color: #fff; color: #000; padding: 0.1em">bold</b>)</p>
          <br>
          <p>Has an internal IR, does some optimization (<a href="http://mozakai.blogspot.com/2012/05/reloop-all-blocks.html">relooper</a>, etc.)</p>
        </section>

        <section>
          <h2>2011</h2>
          <p>Emscripten's <strong>JS optimizer</strong></p>
          <p>Optimizes JS, written in JS (again, great for experimentation)</p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR</td>
            <td>&rarr;</td>
            <td>JS compiler</td>
            <td>&rarr;</td>
            <td><b>JS optimizer</b></td>
            <td>&rarr;</td>
            <td style="color: #c81">JS</td>
          </tr></table></center>
          <br>
          <p>Does various peephole optimizations, later did more complex optimizations too (registerize in 2012)</p>
        </section>

        <section>
          <h2>2013</h2>
          <p><a href="https://en.wikipedia.org/wiki/Asm.js">asm.js</a> is now a thing, less need for radical experimentation</p>
          <p><a href="https://github.com/kripken/emscripten-fastcomp">fastcomp</a>: LLVM asm.js backend, replaces the JS compiler</p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR</td>
            <td>&rarr;</td>
            <td><b>asm.js backend</b></td>
            <td>&rarr;</td>
            <td>JS optimizer</td>
            <td>&rarr;</td>
            <td style="color: #c81">JS</td>
          </tr></table></center>
          <br>
          <p>Big improvement in compile times</p>
        </section>

        <section>
          <h2>2014</h2>
          <p>Rewrite the JS optimizer in C++</p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR</td>
            <td>&rarr;</td>
            <td>asm.js backend</td>
            <td>&rarr;</td>
            <td>JS optimizer <b>(C++)<b></td>
            <td>&rarr;</td>
            <td style="color: #c81">JS</td>
          </tr></table></center>
          <br>
          <p>Another big improvement in compile times</p>
        </section>

        <section>
          <h2>2015</h2>
          <p><a href="http://webassembly.org/">WebAssembly</a> is coming, we need ways to compile to it</p>
          <br>
          <p>Two parallel efforts are begun:</p>
          <hr>
          <p><strong>1.</strong> <a href="http://lists.llvm.org/pipermail/llvm-dev/2015-June/086850.html">LLVM WebAssembly backend</a>, from scratch</p>
          <p><strong>2.</strong> <a href="https://github.com/WebAssembly/binaryen/blob/master/src/asm2wasm.h">asm2wasm</a> which translates asm.js into WebAssembly</p>
          <hr>
        </section>

        <section>
          <p>Why two?</p>
          <br>
          <p>asm2wasm is an <a href="http://kripken.github.io/talks/wasm.html">easy way</a> to get our existing toolchain to emit WebAssembly, gives us something guaranteed to work</p>
          <br>
          <p class="fragment">Looking forward, new WebAssembly backend won't suffer from asm.js's limitations (like no i64s) and can perhaps benefit from more LLVM codegen opts</p>
        </section>

        <section>
          <p>We quickly got asm2wasm working:</p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR</td>
            <td>&rarr;</td>
            <td>asm.js backend</td>
            <td>&rarr;</td>
            <td>JS optimizer</td>
            <td>&rarr;</td>
            <td><b>asm2wasm</b></td>
            <td>&rarr;</td>
            <td style="color: #c81">wasm</td>
          </tr></table></center>
          <br>
          <p>Helped during the wasm spec process, let us create <a href="http://webassembly.org/demo/">demos</a>, etc.</p>
        </section>

        <section>
          <p>asm2wasm is part of the <a href="https://github.com/WebAssembly/binaryen/">Binaryen</a> project, which has an <a href="http://kripken.github.io/talks/binaryen.html">optimizer</a>, leading to</p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR</td>
            <td>&rarr;</td>
            <td>asm.js backend</td>
            <td>&rarr;</td>
            <td>JS optimizer</td>
            <td>&rarr;</td>
            <td>asm2wasm <b>+ wasm optimizer</b></td>
            <td>&rarr;</td>
            <td style="color: #c81">wasm</td>
          </tr></table></center>
          <br>
          <p>Optimizer can run standalone, but asm2wasm can also run it in parallel to itself for fast compile times</p>
        </section>

        <section>
          <p>The Binaryen optimizer kept improving, til we didn't need the JS optimizer any more</p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR</td>
            <td>&rarr;</td>
            <td>asm.js backend</td>
            <td>&rarr;</td>
            <td>asm2wasm<br>+ wasm optimizer</td>
            <td>&rarr;</td>
            <td style="color: #c81">wasm</td>
          </tr></table></center>
          <br>
          <p>Big improvement in compile times</p>
          <p class="fragment"><strong>Note</strong>: we don't need to emit proper JS or asm.js anymore...</p>
        </section>

        <section>
          <p><strong>wasm-only</strong> mode</p>
          <p>Adds some special intrinsics to the asm.js backend's output, for i64s and other things asm.js couldn't handle well (bitcasts, copysign, etc.)</p>
          <br>
          <pre><code contenteditable>
  function example(x, y) {
    x = i64(x); // receive 2 i64 params
    y = i64(y);
    var z = i64(); // declare an i64 local
    if (i64_eq(x, y)) { // compare two i64s
      return i64_trunc(x) | 0; // truncate to i32
    }
    return 0;
  }

</code></pre>
        </section>

        <section>
          <p><strong>Current state of asm2wasm toolchain:</strong></p>
          <br>
          <center><table><tr>
            <td style="color: #c81">LLVM IR</td>
            <td>&rarr;</td>
            <td><b>"asm.js"</b> backend</td>
            <td>&rarr;</td>
            <td>asm2wasm<br>+ wasm optimizer</td>
            <td>&rarr;</td>
            <td style="color: #c81">wasm</td>
          </tr></table></center>
          <br>
          <p>Between the backend and asm2wasm we use that asm.js<strong>-ish</strong> language we just saw (which has yet to be named)</p>
        </section>

        <section>
          <h2>Benchmarks</h2>
          <p>Compare asm.js, wasm with just JS optimizer, wasm with JS+binaryen, wasm with just binaryen, and finally wasm with just binaryen + wasm-only mode</p>
          <p>make sure to inclue the i64 benchmark</p>
        </section>

        <section>
          <h2>LLVM WebAssembly backend</h2>
          <br>
          <p>Progress towards stability, but still not there</p>
          <br>
          <p>Compilation times are slower than asm2wasm, a general LLVM issue (can be made less noticeable through separate compilation, which is in progress)</p>
          <br>
          <p>Not ready for benchmarking or code size measurements yet</p>
        </section>

        <section>
          <h2>The Future</h2>
          <br>
          <hr>
          <p><strong>Good we have both the asm2wasm and WebAssembly backend options</strong></p>
          <br>
          <p>Each approach has benefits, still learning here</p>
          <hr>
          <br>
          <p class="fragment">Thank you for listening.</p>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: 'default', //Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

          // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
