<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Big Web App? Compile It!</title>

    <meta name="description" content="Big Web App? Compile It!">
    <meta name="author" content="Alon Zakai">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h1>Big Web App?<br>Compile It!</h1>
          <h3>Alon Zakai / Mozilla</h3>
        </section>

        <section>
          <h2>Compiling to JavaScript</h2>
          <ul>
            <li>JavaScript is standards-based and runs in all web browsers</li>
            <li>No better way to get your code to people, just give them a URL</li>
            <li>But other languages can be used too, you just need to <b>compile</b> them to JavaScript</p>
          </ul>
        </section>

        <section>
          <h2>First set of demos</h2>
          <p>BananaBread, Qt, matplotlib</p>
        </section>

        <section>
          <h2>Compiling to JavaScript:<br>Nothing New!</h2>
          <ul>
            <li><b>2006</b>: <b>Google Web Toolkit (GWT)</b>, compiles Java into JavaScript</li>
            <li><b>2007</b>: <b>pyjamas</b>, compiles Python into JavaScript</li>
            <li>etc.</li>
          </ul>
        </section>

        <section>
          <h2>Widespread Adoption</h2>
          <ul>
            <li><b>Java (GWT)</b> used in <a href="http://www.blogger.com/">Blogger</a>, many enterprise apps</li>
            <li><b>C# (Script#)</b> used in <a href="http://office.microsoft.com/en-us/web-apps">Microsoft Office Web Apps</a></li>
            <li>Such applications can consist of <a href="http://blogs.msdn.com/b/ie/archive/2011/11/22/evolving-ecmascript.aspx">hundreds of thousands of lines of code</a> or more</li>
          </ul>
        </section>

        <section>
          <h2>Plenty of Languages</h2>
          <ul>
            <li><a href="https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS">Jeremy Ashkenas's list</a> has over a hundred</li>
            <li class="fragment">Two main kinds:
              <ul>
                <li class="fragment"><b>Established</b> languages: C, C++, Java, C#, Python, etc.</li>
                <li class="fragment"><b>New languages</b> intended for compilation to JavaScript: CoffeeScript, TypeScript, Dart, Roy, etc.</li>
              </ul>
            </li>
            <li class="fragment">I'll focus on <b>C and C++</b></li>
          </ul>
        </section>

        <section>
          <h2>Why is this approach successful?</h2>
        </section>

        <section>
          <h2>1. Preference for other languages</h2>
          <ul>
            <li>Static typing</li>
            <li>Existing tools</li>
          </ul>
        </section>

        <section>
          <h2>2. Performance</h2>
          <p>JavaScript engines have gotten fast enough to run large compiled codebases</p>
          <p class="fragment">Late 2008/early 2009: <b>V8</b>, <b>TraceMonkey</b>, and <b>Nitro</b> were released, and the race for JavaScript speed was on</p>
          <p class="fragment">That race <b>enabled</b> running large compiled codebases</p>
        </section>

        <section>
          <h2>Performance: Beyond "enabling"</h2>
          <ul>
            <li>Compiled JavaScript can be <b>faster</b> than "regular" handwritten JavaScript</li>
            <li class="fragment">Wait, compiled JavaScript is a <b>subset</b> of JavaScript! How can it be faster?</li>
          </ul>
        </section>

        <section>
          <h2>One Step Back:<br>How Compilation Works</h2>
          <ul>
            <br>
            <p><b style="color: #ff7700">C/C++</b> &nbsp&nbsp <b>=></b> &nbsp&nbsp <b style="color: #7744aa">LLVM</b> &nbsp&nbsp <b>=></b> &nbsp&nbsp <b style="color: #0077ff">Emscripten</b> &nbsp&nbsp <b>=></b> &nbsp&nbsp <b style="color: #77aa44">JavaScript</b></p>
          </ul>
        </section>

        <section>
          <h2>LLVM Optimizations</h2>
          <p><b>LLVM's optimizer</b> uses type information to perform many useful optimizations. Decades of work have gone into developing optimization passes for C/C++ compilers.</p>
          <br>
          <p><small><span style="color: #ccc">...dce</span><span style="color: #999">, inline</span><span style="color: #666">, constmerge</span><span style="color: #333">, constprop</span><span style="color: #000">, dse</span><span style="color: #000">, licm</span><span style="color: #333">, gvn</span><span style="color: #666">, instcombine</span><span style="color: #999">, mem2reg</span><span style="color: #ccc">, scalarrepl..</span></small></p>
        </section>

        <section>
          <h2>LLVM Optimizations</h2>
          <p>These optimization are only available for compiled code!</p><p>Reproducing them manually on a huge "normal" JavaScript codebase would be
            <ul>
              <li>extremely <b>hard and time-consuming</b>, and</li>
              <li>make the code <b>less maintainable</b></li>
            </ul>
          </p>
        </section>

        <section>
          <h2>JavaScript Engine Optimizations - 1</h2>
          <ul>
            <li>Modern JavaScript engines can <b>infer types</b> at runtime</li>
            <li>This especially helps on code that is implicitly typed - which is exactly what compiled code is!</li>
          </ul>
          <p>
            <pre><code contenteditable>
  function compiledCalculation() {
    var x = f()|0;  // x is a 32-bit value
    var y = g()|0;  // so is y
    return (x+y)|0; // 32-bit addition, no type or overflow checks
  }
            </code></pre>
          </p>
        </section>

        <section>
          <h2>JavaScript Engine Optimizations - 2</h2>
          <ul>
            <li>Modern JavaScript engines optimize <b>typed arrays</b> very well</li>
            <li>Compiled code can use a singleton typed array as memory</li>
          </ul>
          <p>
            <pre><code contenteditable>
  var MEM = new Uint8Array(1024*1024);

  function compiledMemoryAccess(x) {
    // ...
    MEM[x] = MEM[x+10]; // read from x+10, write to x
    // ...
  }
            </code></pre>
          </p>
        </section>

        <section>
          <h2>Benchmarks</h2>
          <img width="1123" height="489" src="mloc1b.png">
        </section>

        <section>
          <h2>About 4x slower than native.<br>Can we do better?</h2>
          <h2 class="fragment" style="color: #f73">Yes!</h2>
        </section>

        <section>
          <h2>asm.js</h2>
          <p><a href="https://github.com/dherman/asm.js">asm.js</a> is a research project at Mozilla that aims to formally
             define the subset of JavaScript that compilers like Emscripten and Mandreel
             <b>already</b> target: implicitly-typed computations, singleton typed array, etc.
          </p>
        </section>

        <section>
          <h2>asm.js</h2>
          <pre><code contenteditable>
function strlen(ptr) {
  ptr = ptr|0;
  var curr = 0;
  curr = ptr;
  while (MEM32[curr>>2]|0 != 0) {
    curr = (curr + 1)|0;
  }
  return (curr - ptr)|0;
}
          </code></pre><br>
          <ul>
>> 2 in other place before
            <li class="fragment">We ensure that ptr is always an integer</li>
            <li class="fragment">We want to read from address curr</li>
            <li class="fragment">Additions and subtractions are all 32-bit</li>
          </ul>
        </section>

        <section>
          <h2>asm.js - Formal type system benefits</h2>
          <ul>
            <li>Can validate that a compiler generates JavaScript that fits the spec</li>
            <li>JavaScript engines can analyze code using the spec and optimize more easily</li>
          </ul>
        </section>

        <section>
          <h2>asm.js - Easier Optimization</h2>
          <ul>
            <li>Types of variables pop out of the type system execution XXXX - no need to observe type information and recompile at runtime</li>
            <li>Guarantee that there are no speed bumps: No exceptions can be thrown, no variable has more than one type, etc.</li>
          </ul>
        </section>

        <section>
          <img width="1098" height="491" src="mloc2b.png">
        </section>

        <section>
          <h2>asm.js - benefits</h2>
          <ul>
            <li><b>Faster code execution</b> - around <b>2X</b> slower than native (comparable to Java, C#)
              <ul><li>Optimizations can be done in a straightforward way in existing JavaScript engines,
                      working prototype in Firefox already</li></ul>
            </li>
            <li class="fragment">Code is just a subset of JavaScript
              <ul>
                <li>Code <b>already</b> runs in all browsers</li>
                <li><b>No</b> need for new standards</li>
              </ul>
            </li>
          </ul>          
        </section>

        <section>
          <h2>Let's see asm.js in action!</h2>
            <p>Demos - BananaBread, Qt, bullet, mruby, gnuplot</p>
            BananaBread numbers, nt just demo
        </section>

        <section>
          <h2>asm.js FAQ</h2>
          <ul>
            <li class="fragment">This is <b>not</b> a new language. It's just a subset of JavaScript that compilers can target. It isn't meant to have cool syntax features or anything like that.</li>
            <li class="fragment">The current 2X speed factor compared to native code is just the beginning</li>
            <li class="fragment">This isn't some far-off dream. You can use asm.js right now: Compile your code with `emcc -s ASM_JS=1`, run it in Firefox Nightly and check for messages in the web console about "asm.js compiled alsdsdsdsdsXXX". And it runs properly in all other browsers.</li>
            <li class="fragment">Limitations: Not all C/C++ code can be compiled to asm.js yet, for example C++ exceptions and setjmp/longjmp, but we plan to fix that.</li>
          </ul>
other languages! java, C#
        </section>

        <section>
          <h2>Ok, compiled code can be fast. Great for C/C++, what else?</h2>
          <ul>
            <li>Java, C#: XMLVM demo, etc. TODO</li>
          </ul>
        </section>

        <section>
          <h2>How to port your codebase..</h2>
          <ul>
            <li>TODO</li>
          </ul>
        </section>

        <section>
          <h2>How to write a new codebase..</h2>
          <ul>
            <li>TODO</li>
          </ul>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: 'default', //Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
          // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
